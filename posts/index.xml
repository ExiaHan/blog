<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on ExiaHan&#39;s Blog</title>
    <link>http://blog.exiahan.com/posts/</link>
    <description>Recent content in Posts on ExiaHan&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 15 Feb 2020 10:19:20 +0800</lastBuildDate>
    
	<atom:link href="http://blog.exiahan.com/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Debug Java via VSCode</title>
      <link>http://blog.exiahan.com/posts/debug_java_via_vscode/</link>
      <pubDate>Sat, 15 Feb 2020 10:19:20 +0800</pubDate>
      
      <guid>http://blog.exiahan.com/posts/debug_java_via_vscode/</guid>
      <description>This is place holder.</description>
    </item>
    
    <item>
      <title>Play With RFiD For Fun And Convenient</title>
      <link>http://blog.exiahan.com/posts/play_with_rfid_for_fun_and_convenient/</link>
      <pubDate>Sat, 15 Feb 2020 10:09:00 +0800</pubDate>
      
      <guid>http://blog.exiahan.com/posts/play_with_rfid_for_fun_and_convenient/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Happy_New_Year_2020</title>
      <link>http://blog.exiahan.com/posts/happy_new_year_2020/</link>
      <pubDate>Wed, 01 Jan 2020 03:35:24 +0800</pubDate>
      
      <guid>http://blog.exiahan.com/posts/happy_new_year_2020/</guid>
      <description>2019就像一枚装了火箭发动机但是燃料管线时好时坏的宇宙飞船，刺激无边的把我送到2020的家门口。刺激归刺激，沿途的经历对我来说都是可以吸取到经验，所以懒惰如我最终还是在19年尾和20开头的这几天，趁我对19年的记忆还没被时间抹去，记录下来，好好封存，说不定经年历月后也会变成一坛醇酒。ExiaHan, 2019 Concert， 现在开始:)
花花世界 &amp;ndash; 樱，一出世便由命
一直相信你生命中遇到的每一个人都会教会你一些道理，而遇到他们也是命中注定，但是当然，不见得所有人都会用你能接受的方式向你传递你宿命中应该得到的经验教训，所以伤痛也就在所难免，喜怒哀乐，悲欢离合，所有所有的一切，都有意义。&amp;ndash; 丁香丹桂茉莉都可爱 清楚笑望 活每一秒亦流丽潇洒
六月飞霜 世界怪得夸张 &amp;ndash; 大时代烟花结束
我们是幸运又不幸运的，幸运在跻身于一个秩序又混乱的时代，体验到了过去几千年里所有人想都不敢想的新技术；而不幸在于当你对这个世界充满信心的时候总会发现每一年值得你沸腾的事情和让你愤怒的事情相比之下总是后者居多，前者到头来看更像是所谓阴险有暗戳戳让你喝下去的毒鸡汤。但是奇妙就妙在最终你能看到的总结里总是无瑕又闪耀，闪耀到你自己都开始相信那些坏事从没发生过。 &amp;ndash; 谁来斗胆讲仙丹会断肠 谁有胆去相信过激立场
旋律怎制定量度 人心总有阴险磊落 &amp;ndash; 当 习惯附和大家讲的真理都得到奖赏
人心是复杂的，椰子状的红色外衣内包裹着太多太多的情绪，又或者说，这世间最邪恶之物不是各种传奇神话中的域外生物，是人心，你永远猜不到一个即将行恶之人的心会有多坏，所以你总会遇到有人可以厚着脸皮向你发出低于你道德底线的要求，他们会把自己的目的用所谓的商量粉饰光亮，再利用你高于他们的道德标准反向绑架，迫你于墙角，让你只能接受。&amp;ndash; 你要我让步 设起圈套
听到很多歪理 大家都一于少理 &amp;ndash; 宁愿拿去放屁
不管到哪里，总会有人对你说，要长大，理由无外乎“这个世界就是这样”，“我当初也怎样怎样，现在不也是怎样怎样”。圆滑左右，笑里藏刀，自私自利，心冷如刀，拐弯抹角，皮肉假笑。不管走到哪里，总有人要带你往粪坑里跳。这是长大么？ &amp;ndash; 当人大了 你有没有 哈哈哈哈哈哈笑
你要陪住我 &amp;ndash; 我怕发恶梦
人怕孤单，人有所爱，孤单时会想被陪伴，思念时也渴望陪伴，但能在孤单时被所爱之人陪伴，却是很难，男男女女乐于在所爱之人面前变回孩童，撒娇赌气，渴望被爱。幼稚不足，会让场面尴尬；太过索求，又招来厌烦，最长情的告白到底要多么精准才能获得？ &amp;ndash; 说来这个事情也奇怪 只要三步之内有你在 我拳头 就放开 睡得像小孩
得不到的永远在骚动 &amp;ndash; 烂熟透红 空洞了的瞳孔
执念会摧毁一切。执字加身，仿佛心中上锁，纵心有七窍也不得脱，一切所得之美好如千年道行一朝尽丧。所以轮回之前，奈何桥上，才要饮孟婆黄汤，断一世执念。 &amp;ndash; 终于掏空 终于有始无终 都落空
你要静候再静候就算失收始终要守 &amp;ndash; 谁都辛酸过 哪个没有
想法太美好会招致来自现实世界的无情暴击。所谓悉心栽种全力灌注，可能自己花费了很大代价，但在别人看来也不过是自我感动，如前面所说，执念太深，毁你所有。每个人都期待葡萄可以酿成红酒，但总会有人最终寂寞白头。但好在磕磕绊绊留下的伤痕总会痊愈，葡萄周围既被别人扎起篱笆，那便留底你尝试跨越时硌伤你的石头。 &amp;ndash; 想想天的一边亦有个某某在等候
情爱就似垃圾 残骸虽会腐化 &amp;ndash; 庭园中最后也 开满花
看着抓在手里的未熟果实逐渐腐败，而自己又无能为力，大多会产生深深的挫败，最终失心落魄弃于庭院，蹲坐在台阶上掩面。殊不知可能你埋头的时候，已有人为你撑伞遮阳挡雨，所以何不抬起头来，一起静静看着已经烂掉的果实溶于泥土，而后撒下新种，在腐坏之上，重生新花。所谓枯木逢春，老树新芽。 &amp;ndash; 随时能欢喜亦随时嫌弃 不用再记起怎去忘记</description>
    </item>
    
    <item>
      <title>Summary of 2018</title>
      <link>http://blog.exiahan.com/posts/summary_of_2018/</link>
      <pubDate>Mon, 04 Feb 2019 23:26:27 +0800</pubDate>
      
      <guid>http://blog.exiahan.com/posts/summary_of_2018/</guid>
      <description>2018 2018年对咱来说是结束也是开始 ———— 四月份的毕业证意味着相对无忧无虑的学生时代的终结，同时签下的工作合同也表示作为”社会人“的开始(可惜咱不是佩奇:))。咱在学校是幸运的，不仅有厉害的室友，还有厉害的各位老师，还有各路非常非常厉害的学长学弟，多谢各路大佬一路带咱平地起飞，咱这几年学到的东西确实不少，当然咱这几年学到的学习方法会帮助咱一路前行。 工作方面，拿大彪哥的说法是咱们终于都做了”社畜“，很幸运的进到了现在的公司，进到了非常好的Team，遇到了无敌强的老大和无敌强的同事们。多谢各路大佬不吝赐教带咱继续前行，让咱有幸抱着大腿去了两趟霓虹(必须要跪谢Team，跪谢公司)，学到了在学校不知道的东西，同时也扭转了部分不适用于工业的学院思维。 生活方面，作为YoungHo Lee 歌词里的”连头款也凑不到“的”无为青年“，压力肯定是有的，但是就像很早以前的一个”酱油“(没错，真的是酱油广告，但是我不打酱油:))说的，”生活是道菜“，酸甜苦辣总归都会尝到，所以咱会自然对待(毕竟作为Eason Chan的Fan，”黑暗过会是晨曦“是时不时就会唱出来的)。
2019 对于2019年，咱不能说一定要怎么怎么样，但是咱总会尽力让2019好于2018，不然也太对不起2019 &amp;gt; 2018这个不等式了2333333。 其实鸭，还有好多没学，再把2018年没干完的计划累到2019年，咱现在只能对自己说不管什么时候都尽量让自己能够”百尺竿头，更进一步“啦～(真要说的话，借用大佬的话，希望咱新的一年可以Bug多多，Paper多多，当然最好能有个不嫌弃咱的妹子哈哈哈哈哈～)
就这样，祝大家己亥年新年快乐，万事如意，想长个的长个，想变壮的变壮，想变强的变强(当然头发还是要有的，不能做埼玉老师啊哈哈哈哈)，想变大胸的立马大胸(逃～～～～～)
最后吐槽一下，今年春晚一如既往的不太好看，也就相声小品还行(当然也要切掉某些惯例那啥桥段才行)，然后如果你发现上面某些地方逻辑不连贯，那肯定是我在看春晚小品相声哈哈哈哈～
  </description>
    </item>
    
    <item>
      <title>Build SQLITE For Android</title>
      <link>http://blog.exiahan.com/posts/build_sqlite_for_android/</link>
      <pubDate>Wed, 01 Aug 2018 22:18:20 +0800</pubDate>
      
      <guid>http://blog.exiahan.com/posts/build_sqlite_for_android/</guid>
      <description>Describe Recently I need to use sqlite3 to quickly modify values in a db file located in an android device. Usually the easy way is to directly copy an sqlite3 ELF file from an exist AOSP rom&amp;rsquo;s side products of target architecture, but sometimes we may not have any aosp rom built on our disk or even no aosp source files on disk. So it may be not convenience to archive a executable sqlite3 ELF file from a built rom&amp;rsquo;s side products.</description>
    </item>
    
    <item>
      <title>x64 and arm64 ABI in Linux</title>
      <link>http://blog.exiahan.com/posts/x64_and_arm64_abi_in_linux/</link>
      <pubDate>Fri, 01 Jun 2018 22:10:20 +0800</pubDate>
      
      <guid>http://blog.exiahan.com/posts/x64_and_arm64_abi_in_linux/</guid>
      <description>x64 and arm64 ABI in Linux TL;DR Ok, it has been a few months since Arch Linux announced that it will only provide x64 image in the future. Android also has been support x64 and arm64 for a long time. Seems that it&amp;rsquo;s true that x86 is on the way of out of time. So it&amp;rsquo;s time to learn some thing about the ABI in x64 and arm64.
PS: If you&amp;rsquo;ve read the ABI manual about Linux on X64/Arm64, there is no need to read this article.</description>
    </item>
    
    <item>
      <title>Start To Use Nginx Hexo and Let&#39;s Encrypt</title>
      <link>http://blog.exiahan.com/posts/start_to_use_nginx_hexo_and_lets_encrypt/</link>
      <pubDate>Mon, 30 Jan 2017 03:51:33 +0800</pubDate>
      
      <guid>http://blog.exiahan.com/posts/start_to_use_nginx_hexo_and_lets_encrypt/</guid>
      <description>TL;DR It&amp;rsquo;s just a record for myself. It may contain errors. But it still can help you if you don&amp;rsquo;t know how to start the config. For a Offical instruction, you may try this in Digital Ocean. And what I think is that: The tutorials in DigitalOcean is much better that what is written in some linux distribution&amp;rsquo;s wikipage like ubuntu&amp;hellip;.
Abstract It is time to embrace https since chrome begin to mark website which use http as unsafe.</description>
    </item>
    
    <item>
      <title>Expand A Logical Volume In LVM</title>
      <link>http://blog.exiahan.com/posts/expand_a_logical_volume_in_lvm/</link>
      <pubDate>Sun, 29 Jan 2017 03:29:32 +0000</pubDate>
      
      <guid>http://blog.exiahan.com/posts/expand_a_logical_volume_in_lvm/</guid>
      <description>Abstract This blog is used to record the instructions about how to expand a logic volume in lvm.
CAUTION!
 What I write here may not completely right because there have been one month passed since I complete migrate my data to SSD. Resize volume may cause data lost, so be carefully. Your warranty is now void. I am not responsible for bricked devices, dead SD cards, thermonuclear war, or you getting fired because the alarm app failed and anyother errors.</description>
    </item>
    
    <item>
      <title>Happy_Chinese_New_Year_In_2017</title>
      <link>http://blog.exiahan.com/posts/happy_chinese_new_year_in_2017/</link>
      <pubDate>Sun, 29 Jan 2017 02:16:22 +0800</pubDate>
      
      <guid>http://blog.exiahan.com/posts/happy_chinese_new_year_in_2017/</guid>
      <description>TL;DR Below is written by a man that with poor English skills. Read carefully if you really want to read.(But I will say thank you if you really read all the contents below. :) )
Happy Chinese new year! In China, all the Chinese now say goodbye to the &amp;ldquo;Monkey Year&amp;rdquo; and step into the &amp;ldquo;year of Chicken&amp;rdquo;. Watching the Spring Festival Gala Evening provided by CCTV is a tradition for almost every Chinese.</description>
    </item>
    
    <item>
      <title>Android AntiDebug and Signature Verify Example</title>
      <link>http://blog.exiahan.com/posts/android_antidebug_and_signature_verify/</link>
      <pubDate>Sat, 09 Jan 2016 21:44:08 +0800</pubDate>
      
      <guid>http://blog.exiahan.com/posts/android_antidebug_and_signature_verify/</guid>
      <description>Reference:grafx, IT Dreamer
Introduction We can use lots of tools like apktool, baksmali, dex2jar to convert a android app to java source code easily. So now most of our developers will put the core-function in the native level(with C/C++ code) because the arm-assembly language or C pseudo code are more difficult to read than java. But others can still read the native code if they really want, they can use IDA to read .</description>
    </item>
    
    <item>
      <title>IDF.CN Practice 01</title>
      <link>http://blog.exiahan.com/posts/idf_cn_practice_01/</link>
      <pubDate>Wed, 30 Dec 2015 22:12:08 +0800</pubDate>
      
      <guid>http://blog.exiahan.com/posts/idf_cn_practice_01/</guid>
      <description>0x1 Preparation 既然决定要做，那就加油，写在开头，打好基础，加油吧。 Exia，斩获未来。。
0x2 Start 一、牛刀小试 被改错的密码 从前有一个熊孩子入侵了一个网站的数据库，找到了管理员密码，手一抖在数据库中修改了一下，现在的密码变成了 cca9cc444e64c8116a30la00559c042b4，那个熊孩子其实就是我！肿么办求解！在线等，挺急的。。
看起来挺像md5,直接拿去在线破，结果提示有问题，再一看，长度有问题，md5是32位哈希，这玩意33位，用python生成去掉其中某个字符的序列，然后再一个个在线破，发现是cca9cc444e64c8116a30a00559c042b4，解出来是idf，所以flag是wctf{idf}
 啥 题目就是一张图片，bless打开看hex，在底部找到flag：wctf{mianwubiaoqing__}
 ASCII码而已 明显一看是unicode，找个在线转换，flag为wctf{moremore_weibo_fans}
 摩斯密码 一段morsecode &amp;ndash; &amp;mdash; .-. &amp;hellip; . -.-. &amp;mdash; -.. . 在线解一下，flag为wctf{morsecode}
 聪明的小羊 一只小羊跳过了栅栏，两只小样跳过了栅栏，一坨小羊跳过了栅栏&amp;hellip; tn c0afsiwal kes,hwit1r g,npt ttessfu}ua u hmqik e {m, n huiouosarwCniibecesnren.
看题目就想到古典加密，既然是栅栏，那就栅栏密码吧，正好带学一下栅栏密码，就写了个python的加解码脚本，跑一下看到flag:wctf{C01umnar}
二、包罗万象 MISC 图片里的英语 给了一张小李，binwalk一下。看到有个rar，dd提取出来，解压，得到一长flag，恩，没错，就是那张赵本山的图片，may the force be with you，然后首字母大写，wctf{Mtfbwy}
 抓到一只苍蝇 给了一个pcapng网络dump包，根据他说的内容，和包名带有fly，搜索包内容，找下字符串fly，成功找到，发现是上传了一个附件fly.rar,分成了5个包上传，第一个post指出fly.rar大小为525701，接着5个包都是传向ftn开头服务器，所以猜测是附件内容，前个都是131436大小，最后一个1777，（131436×4 + 1777 - 525701） / 5 = 364，所以每个包开头364部分为分包后的包头，dd导出内容，skip掉头364字节，然后cat成fly.rar，比较下post里给的md5,一样。
解压工具打开，提示文件损坏，看上去因该不是正常的加密，而且也根本没有其他密码的信息，推测可能改了文件头，bless修改加密位（第24个字节改为0x80）：
解压得到一个flag.txt，打开发现不行，binwalk一看是个pe。。。不过里面有png，而且很多60x60的，但有一个280x280的，dd解出来，打开是一张二维码，扫一下，flag为:flag{m1Sc_oxO2_Fly}，不过说没改格式，额，所以应该是wctf{m1Sc_oxO2_Fly}
三、初探乾坤 PPC 简单编程-字符统计 给了一串字符串，让统计个数，妥妥的python，count函数直接搞定。直接提交，发现有坑，仔细看了下题目是要求2秒内搞定，那就只能自动接受内容然后发送post请求了</description>
    </item>
    
    <item>
      <title>MSC2015 WriteUp</title>
      <link>http://blog.exiahan.com/posts/msc2015_writeup/</link>
      <pubDate>Thu, 22 Oct 2015 17:45:08 +0800</pubDate>
      
      <guid>http://blog.exiahan.com/posts/msc2015_writeup/</guid>
      <description>第一题 和去年类似，程序运行后要求输入，输入正确的值才能得到答案，打开DDMS监控，尝试输入字符串查看log并观察其行为，Log里有提示invalid int，说明要求输入的是个int范围内的数。
把程序丢到jeb里查看，发现关键函数check无法被解析
使用apktool d -d反编译查看smali代码，看到反编译出了5万行代码，其中有大量通过动态反射调用的函数，但是调用的都是java库函数，函数名硬编码成Reverse字符串，运行时逆转成真正的函数名。但是猜测既然是输入的数字，应该会有比较，使用apktool b -d重打包，真机运行，使用netbeans动态调试，并且在check方法的所有cmp处下断点，最终在45540行的比较处发现，如果比较结果是不等，那么返回false，如果是true，则通过校验，程序显示蓝色字。
多次运行，输入不同的数字，发现v10会变化，但是v4是定值，520676，说明v10应该和输入有关，向上找会修改v10的地方，找到第36111行，在此处下断，运行。
输入123456789，发现第一次断在此处v20值是123456790,继续运行会再次断在此处，如此循环，循环结束后继续运行会跳到关键的比较行，在比较行上有把v6和v4相加存入v4的操作。查找循环的比较条件，可以看到15983行有个v0和v5的比较，其中v5是定值1001,直接修改v0为1001,则最终v4的值不再是520676,同时v10的值也不再是之前输入123456789的值，所以36111行处应该和计算过程相关，是核心过程，继续向上找36111行v20的相关行，找到10832行。
重新运行程序，输入123456789，程序断在此处是，v10是输入值，v8的值从v0处取得，v0的值变化规律为从1开始递加4,一直到1001,然后15983行的比较生效，跳转，最终运行到关键比较点。 使用python脚本计算1到1001的递增为4的累加值，为124750，让程序一直运行到比较点，观察v10的值为123581539，减去124750,刚好为输入。
用v4的值减去124750,得到395926，即为key
第二题 首先丢到jeb里分析，Ch函数里有个Morse码，解码后是WOJIUSHIDAAN，输入后不对，猜测是个坑。。 同时Ch里有做签名校验，重打包时需要patch掉。 apktool d -d 反编译，同时修改Ch的smali代码
116 a=0;// #v2=(Reference,Ljava/lang/String;); 117 a=0;// const-string v1, &amp;quot;WJmkxxkkGnYbExi3dqzeaA&amp;quot; ...... 120 a=0;// 121 a=0;// move-result v1 122 a=0;// 123 a=0;// #v1=(Boolean); 124 a=0;// if-eqz v1, :cond_0 //需要修改的行 同时发现有native方法ch用来check，使用ida动态调试，直接闪退，有反调试。静态分析，导出表还有mprotect，同时猜测可能有动态修改执行代码。 最终在init_array里找到两个反调试的入口点,1424和3160
1424和3160里分别有调用到sub_1284和sub_3400，前者很明显去调用fopen读取 proc/pid/status的tracerpid，后者在运行时会被多次调用，包括在动态释放的代码里也会调用，如果返回一个小于0的值，那么会尝试像不可写内存里写值，导致程序崩溃。
使用bless打patch，把1284里的kill调用改为返回0,3400里的返回值改成0,使用的opcode是00 00 A0 E3 mov R0, #0，修改后如图：
重新附加调试器，可以正常调试，在Java_k2015_a2_Ch_ch处下断点，让程序继续运行，输入abcdefg，成功断在native函数ch处，运行到sub_1DE0[0x3CBAFDE0]时单步进入，此时可以看到传入参数为输入
sub_1DE0中输入给了v1,然后mcpy到v43，最终在两个mprotect（其中有动态修改程序代码），后调用了函数loc_24C8[0x3CBB04C8]，步入前先使用idc脚本dump出来libwbox.so,此时的so里含有24C8的代码，可以用来静态分析，然后步入函数，查看其代码，对输入的字符串做了如下变换：
变换后依然有动态修改代码的过程，然后调用loc_14A4[0x3CBAF4A4]，同样调用前dump出来so库，用于静态分析代码算法，在调用前会对输入进行变换，方法是输入的第i个元素的ASCII码加上i再存回数组，此时输入已经变为如下所示：
在loc_14A4中会对输入再次变换，最终生成下面提到的16字节数组，计算方式如图：
如图，用于计算的数组是[1F BC DA FF E6 4C BC 44 F5 B8 13 C8 EC A8 CD BD],计算方式是第i个元素的ASCII码加上上面对应的第i个数，结果保存为一个16字节数组。</description>
    </item>
    
    <item>
      <title>Dump Dex From IJiaMi</title>
      <link>http://blog.exiahan.com/posts/dump_dex_from_ijiami/</link>
      <pubDate>Wed, 07 Oct 2015 23:20:29 +0800</pubDate>
      
      <guid>http://blog.exiahan.com/posts/dump_dex_from_ijiami/</guid>
      <description>内容仅供学习讨论 参考文档： 爱加密动态脱壳，爱加密动态脱壳法，浅谈android逆向分析那些拦路虎，光哥博客
0x1 说在开头 现在有很多软件都是有加壳的，作为安全狗肯定要研究研究，从网上找了点资料，然后找了个用IJiaMi加固的顺着做了一下。
0x2 实验环境  Android 真机，Version 4.1.2， with ROOT &amp;amp; Xposed 某被IJiaMi加固的App IDA调试器 adb  0x3 过程 下断点：
 libc.so fgets fopen libdvm.so _Z21dvmDexFileOpenPartialPKviPP6DvmDex  这里关于为何在fgets和fopen上下断点的原因几乎都有说明，是因为加固措施里有反调试，方法是使用子进程检测父进程是否被ptrace（即被调试），如果有则强制关闭说有进程，而检测方法就是读取
|---/proc/[pid]/status 对于这个我也写了个，大概实现可以看这里：getTracerPid
文件里的TracerPid行，如果为0说明没有被调试，否则就是调试器的PID 所以要在fgets和fopen上下断，找到其打开后获取值的语句，改为0,patch掉反调试
真正调试时发现其实不需要每次都patch掉，只要找到用于反调试的子进程，然后直接休眠掉即可，否则如果碰到变态的每隔几秒就检测一次的加固方式，那就只能一直人工patch了┗&amp;lt;(=｀o′=)&amp;gt;┓哼 ┏&amp;lt;(=｀○′=)&amp;gt;┛哼┏&amp;lt;(=｀o′=)&amp;gt;┓哈┗&amp;lt;(=｀O′=)&amp;gt;┛兮！！
再下来是**_Z21dvmDexFileOpenPartialPKviPP6DvmDex**，位于libdvm.so，libdvm是library-dalvik-virtual-machine，即dalvik虚拟机的核心所在shared object，其中的*_Z21dvmDexFileOpenPartialPKviPP6DvmDex*即为运行一个dex前需要调用的**参与打开dex文件**的一个函数，为什么要在这里下断呢？
去源码dalvik文件夹下执行
grep -rn dvmDexFileOpen 可以找到dvmDexFileOpenPartial函数，其定义位于./dalvik/vm/DvmDex.h:84，如下：
72 /* 73 * Given a file descriptor for an open &amp;#34;optimized&amp;#34; DEX file, map it into 74 * memory and parse the contents. 75 * 76 * On success, returns 0 and sets &amp;#34;*ppDvmDex&amp;#34; to a newly-allocated DvmDex.</description>
    </item>
    
    <item>
      <title>XDCTF2015 WRITEUP(我才不会说我就做出来一题)</title>
      <link>http://blog.exiahan.com/posts/xdctf_writeup/</link>
      <pubDate>Fri, 02 Oct 2015 23:12:46 +0800</pubDate>
      
      <guid>http://blog.exiahan.com/posts/xdctf_writeup/</guid>
      <description>0x1 给大黑阔们跪了 本来准备出去玩的，结果到家后发现要过两天才有人回来，就趁机做了把XDCTF的线上，结果被虐的北都找不到了，看着6星和Sigma一路突突突，只能膜了。。有思路的一共三题，结果最后只做出来1题。。。另外两题做到一大半怎么也进行不下去了。 总体来说虽然没做出来多少，但是感觉XDCTF水平是很高的了，题目也都很虐人（Pia!&amp;lt;(=ｏ ‵-′)ノ☆ 这里写个备忘，毕竟是一次经历。
0x2 没写出来但有思路的的 Reverse 01 一个linux 的elf x64程序，还是挺有意思的，可惜没做出来，逆向功力不够，大概思路：
 入口函数是函数0x4008e1，里面会有ptrace反调试，然后获取输入  这里的输入从分析看应该是要解密后面说到的加密方法的   后面的坑就来了，如果顺着0x4008e1走，最后会打印出来&amp;quot;Congratulations? Key is XDCTF{Input}&amp;quot;，一看就不对 继续看，发现有个函数在0x400787,最后也会打印出来一个flag，而且会吧上面的string的“？”换成“！”，所以这个函数才是真正会吐出flag的过程 解体思路应该是修改执行流到这里，但是问题有三个：  逆向出加密算法 给出能通过的输入 在什么时刻强制从0x4008e1跳到0x400787   因为没搞定上面三个问题，所以没写出来  最后说下里面加密会用到字符串ZzAwZF9DcjRrM3JfZzBfb24=，不过加密算法，我就真不想看了。
Misc 01 这题后来给了tips，也就是org原图。
 先用stegsolv打开zzzzzzyu.png，跳几个plane后可以看到顶部有个条，原图org.png是没的 用stegsolve两张combine一下，然后sub后发现顶部会出现两像素宽的条状区，里面零星分布一些黑色像素点 导出成bmp，去色成黑白 用python 的PIL库把顶部两行的按照像素输出，白色是0,黑色是1,可以得到如下字符串：  11111111111111111111111111111110111111111111111111101011111111111111110111111111111111111011111111111111111111111110111111111111111101011111111111111111111111111111110111111110101110111111111111111111111111111011101110111111111111111111111111110111111111111111111111011111110111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111101111111111111111110101111111011111010111111011111111111111111111111111111111111111111110111111111111111111010111111101111101011111101111111111111111111111111111111101110111111111111111 但是接下来用jpk处理的时候，4bit格式format，然后处理完实在找不到什么特征了。。作罢。。。（o&amp;laquo;(≧口≦)&amp;raquo;o
0x3 解出来的 嘛，怎么着还是做出来一题的，至少不是鸭蛋，咩哈哈哈哈&amp;lt;(=￣_￣)σ…&amp;lt;( ＿ ＿)ノ｜
给了一个数据文件，file一下识别不了格式，strings也没啥有用信息，bless看的时候发现开头几个字符是VIMG&amp;hellip;.fat12&amp;hellip;.VMWare Visual什么的，搜了下，唯独fat12有点信息，但是挂载的话还是会失败。
换用binwalk，可以看到里面有很多东西，但是有两个zip文件，而且最后那个里面有flag.txt，于是把两个都dd出来 不过要说的是dd中间那个的时候，如何能精确的dd出来还是听麻烦的，试了好久，dd出来了一个没有多余附加尾部的zip，如果有更好的方法还希望有人留言说下哈
dd出来后有flag的那个，姑且命名为flag.zip有密码，试着去掉密码位后一样不行，说明不是伪加密，再看没加密的那个，姑且命名为x.zip，发现两个都有个readme.txt
用unzip -v查看了下两个的内容，结果两个readme.txt相同诶，于是想到明文破解，把x.zip里除readme.txt外的文件全部删掉，然后用pkcrack大法，大概用法是
pkcrack -c &amp;ldquo;readme.txt&amp;rdquo; -p raedme.txt -C flag.zip -P x.zip -d ok.zip
 -c是指出加密zip里readme.</description>
    </item>
    
    <item>
      <title>NSCTF2015 WriteUp</title>
      <link>http://blog.exiahan.com/posts/nsctf2015_writeup/</link>
      <pubDate>Fri, 25 Sep 2015 20:56:06 +0800</pubDate>
      
      <guid>http://blog.exiahan.com/posts/nsctf2015_writeup/</guid>
      <description>参加了NSCTF线上比赛，感觉自己水平还是有待提高啊，写一下做出来的题目的备忘
Reverse 0x1 简单的逆向 题目地址：Reverse01
 运行程序，出现CLI程序窗口，提示输入密码，随意输入，提示错误。 使用PEID查看，发现加了ASPACK2.12的壳，使用od加载，看到有pushad操作，使用esp方法脱壳 不需要完整脱壳，在壳程序运行完，dump程序[此步不是必须，但是可以dump出来后查看源码] 回到od，查找字符串，找到提示的那句**&amp;ldquo;please input ns-ctf password&amp;rdquo;**，跳转到引用文字，发现有strcmp比较，比较字符串固定，为**&amp;ldquo;nsF0cuS!x01&amp;rdquo;** 输入上面的字符串**&amp;ldquo;nsF0cuS!x01&amp;rdquo;** 单步跟踪，发现有个jle跳转，如果条件满足会跳过一个函数调用，直接printf出来一个有乱码的flag，推测可能之前还有处理 修改jle跳转为改为**&amp;ldquo;jmp short Reverse0.00401150&amp;rdquo;**，即调用其本来会通过jle跳过的函数，如图：   继续F9运行，程序吐出flag，如图：  0x2 较简单的逆向 题目地址：Reverse02
本题和第一题类似，只不过改成了窗口程序
 运行，发现窗口程序 使用OD或者IDA打开 尝试搜索&amp;quot;Flag&amp;rdquo;，发现有好几个匹配，记下，同时猜测可能和第一题一样有对flag处理 查看导入表，发现是个dialogbox，查找调用，找到0x00401240处的DialogBoxParamA调用，从其参数里找到对应回调处理函数入口为0x00401180 转到0x00401180处，发现有个GetDlgItemTextA的调用，在其下有个call 0x00401070，猜测会在其中处理Flag，修改程序执行流，让其可以执行，跟踪进入此函数，如图：   进入0x00401070后，可以看到上面有个0x00401000的函数，可以看到内部有调用MessageBoxA显示Flag，同时在0x00401070内发现有此函数调用，修改执行流让其可以执行，跟踪进入0x00401000，在MessageBoxA调用前下断，看到真正的flag，如图：  0x3 逆向 题目地址：Reverse03
分析：使用python生成的程序，运行时在本地Temp文件夹里释放文件，通过CreateProcessA运行一个新进程来执行，没搞定。。。。。。。。囧。。
MISC 0x1 Twitter 这题，额。。。啧啧。。一个md5,100块钱，不过有人抖了答案出来
0x2 Wireshark 题目地址：sniffer.pcapng
从题目可以看出来是个抓包题，wireshark打开文件[也可以用Dshell，或者binwalk]
 题目说是下载，猜测在http里，表达式过滤http 看到有个key.rar，服务器为192.168.52.1 dump出key.rar，解压，需要密码 继续查找发现获取rar之前还有个从服务器获取的页面，dump内容保存成html文件，内容有提示密码为nsfocus+5个数字 生成字典，爆破，解压密码为nsfocus56317,打开后获得flag  WEB 0x1 Be Careful 使用chrome dev tools跟踪页面，发现有个301重定向，猜测可能有个默认的动态页面，尝试index.php，发现确实存在，使用wireshark抓包，看到flag在注释里。
###0x2 Decode
题目里给了个php的函数，接受传入的字符串
function encode($str){ $_o = strrev($str); for($_0=0;$_0&amp;lt;strlen($_o);$_0++){ $_c = substr($_o,$_0,1); $__ = ord($_c)+1; $_c = chr($__); $_= $_.</description>
    </item>
    
    <item>
      <title>Dice Write Up</title>
      <link>http://blog.exiahan.com/posts/dice_write_up/</link>
      <pubDate>Fri, 18 Sep 2015 20:01:27 +0800</pubDate>
      
      <guid>http://blog.exiahan.com/posts/dice_write_up/</guid>
      <description>0x1 题目链接：Simple-Reverse-Dice
0x2 拿到程序后运行观察其行为，发现是一个Windows CLI程序，运行后提示是按其要求摇骰子，摇出其指定的点数才能进行到下一步，全部正确则吐出Flag，错误则结束。
运行时程序会有一些提示字符串，记下部分，用IDA打开静态分析。
0x3 使用IDA和Ollydbg进行分析
 在String Tab中找到对应的String，找到其关联的代码，转成C伪代码分析，可以看到程序是一个WinMain程序，查看其变量，发现有两个time类型，推测可能每次摇骰子是随机生成数值。 继续向下，可以看到程序有判断是否有附加调试器：  isDebugerPresent()函数，标记，使用Ollydbg时要记得修改其值，绕过调试器检测   继续向下走的话，可以看到每次判断都是调用随机数生成函数后存入值到内存地址0x0022FE9C处，然后从此内存取值，依次判断是否是3-1-3-3-7，需要注意的是最后一个判断7的时候没有再生成随机数，所以要在判断前直接修改内存为7 再继续，3-1-3-3-7完成后，在显示flag之前，还有一次比较，如果相等会跳到something wrong，所以也要做一次patch 仅按照上述内容patch后发现打出的flag是乱码，猜测可能有其他坑，重新浏览代码发现每次判断roll点正确（即3-1-3-3-7）后，还会判断时间差，如果大于2，就会把用来计算flag的值做一次乘2,所以每次比较完后要在比较时间差处也做patch，防止被乘2 最后发现上面最好patch后，加了横线的描述应该不会发生  #0x4 上述步骤完成，拿到flag，如图：
#0x5
昨晚后光哥给的思路是直接运行前静态改好，然后直接让他跑一下就把flag吐出来了。。。o&amp;laquo;(≧口≦)&amp;raquo;o，炸裂了。。我好蠢。。汪，就这样
顺便把我的暴力方法打的断点图备忘一下：</description>
    </item>
    
    <item>
      <title>Xposed with Android Studio</title>
      <link>http://blog.exiahan.com/posts/xposed_with_android_studio/</link>
      <pubDate>Wed, 02 Sep 2015 16:06:55 +0800</pubDate>
      
      <guid>http://blog.exiahan.com/posts/xposed_with_android_studio/</guid>
      <description>0x1 介绍 Xposed不用说，估计是很多人都知道的神器，通过替换系统文件在zygote(Android应用的孵化器)阶段进行hook，给予了xposed相当于root的权限，使用Xposed来修改修改和定制系统，或者在某些需要的情况下想从一些应用里套点数据，Xposed都是十分在行。 本文简单介绍使用Xposed来套取一个示例Android应用中某个函数运行时传入的参数。
0x2 开工 这篇文章也是作为Xposed插桩的练习记录
引入Xposed框架 不得不说，即使有rovo89的Xposed Tutorial，Android-Studio到目前为止也并不是很让人能轻松上手，特别是eclipse用惯以后，这里要说明一下如何在Android-Stuio中引入Xposed框架包。
 下载xposed框架jar包 创建你的xposed module工程，如&amp;quot;HelloXposedHook&amp;rdquo; 在app/src下创建文件夹xposedLib   之所以要在这里分开说最后一步，是因为目前我知道的有两种方法引入框架而不在生成时包含
 方法一：  把下载好的xposed-bridgeAPI.jar包拖进去，右键，选择add as library 在Project视图下右键项目名，选择open module settings，把xposed-bridgeAPI那一项有compile改成proivde    如图：  方法二：  把下载好的xposed-bridgeAPI.jar包拖进去 在app/xposedLib/路径里创建build.gradle文件，内容如下    apply plugin: &amp;#39;java&amp;#39; dependencies { compile project(&amp;#34;:lib&amp;#34;) provided fileTree(dir: &amp;#39;lib&amp;#39;, include: [&amp;#39;*.jar&amp;#39;]) }  根据xposed tutorial的提示，jar包不能放app/libs，否则会自动包含 xposed的jar包要求仅被引用，而不能包含 所以放xposedLib 并且在module settings里把相关项改成provide
 到这里xposed框架的引入即可成功
创建你的Xposed Module  修改AndroidManifest.xml，加入xposed的meta元素（具体如何参见rovo89的Tutorial）  如下所示：
&amp;lt;application android:allowBackup=&amp;#34;true&amp;#34; android:icon=&amp;#34;@mipmap/ic_launcher&amp;#34; android:label=&amp;#34;@string/app_name&amp;#34; android:theme=&amp;#34;@style/AppTheme&amp;#34; &amp;gt; &amp;lt;meta-data android:name=&amp;#34;xposedmodule&amp;#34; android:value=&amp;#34;true&amp;#34; /&amp;gt; &amp;lt;meta-data android:name=&amp;#34;xposeddescription&amp;#34; android:value=&amp;#34;My First Xposed Module for Hook&amp;#34; /&amp;gt; &amp;lt;meta-data android:name=&amp;#34;xposedminversion&amp;#34; android:value=&amp;#34;30&amp;#34; /&amp;gt; &amp;lt;activity android:name=&amp;#34;.</description>
    </item>
    
    <item>
      <title>ELF_Simple_Shell</title>
      <link>http://blog.exiahan.com/posts/elf_simple_shell/</link>
      <pubDate>Tue, 18 Aug 2015 12:48:57 +0800</pubDate>
      
      <guid>http://blog.exiahan.com/posts/elf_simple_shell/</guid>
      <description>0x00 前言 之前看了ELF文件的文件格式PDF文档，又从看雪论坛和光哥那里看了点so加密的文章，就想试下直接对elf可执行文件加密。现做一点整理和记录，留待备用。
大概流程如下：
 核心代码放到指定节 .init section 加入解密函数decryptFunc 加密程序读取编译好的elf文件，加密指定节 运行时decryptFunc函数解密核心代码 正确执行  0x01 准备工作 要对ELF可执行文件进行处理，首先需要了解ELF文件格式，具体可见上一篇Po主的渣翻译（真的很渣，英语老师已气死），这里对需要用到的地方再进行一次说明：
ELF文件格式 ELF文件组织结构如下：
   Linker View Execution View     ELF Header ELF Header   &amp;hellip;&amp;hellip; &amp;hellip;&amp;hellip;   Section Header Table Section Header Table[Optional]   &amp;hellip;&amp;hellip; &amp;hellip;&amp;hellip;   Program Header Table[Optional] Program Header Table   &amp;hellip;&amp;hellip; &amp;hellip;&amp;hellip;   Sections Segments   &amp;hellip;&amp;hellip; &amp;hellip;&amp;hellip;    ELF文件ELF Header结构如下：</description>
    </item>
    
    <item>
      <title>Study ELF File Format</title>
      <link>http://blog.exiahan.com/posts/study_elf_file_format/</link>
      <pubDate>Fri, 31 Jul 2015 16:30:21 +0800</pubDate>
      
      <guid>http://blog.exiahan.com/posts/study_elf_file_format/</guid>
      <description>前言 为了对Hook， Relocation， 以及一些程序保护技术有更深的了解，正在学习Linux ELF文件格式，所以找到了ELF_Format的文档，这里把里面的一些内容做一下翻译同时记录下。如有错误还请指出，共同学习一起进步啊鲁～ლ(╹◡╹ლ)
正文 简介 ELF是Executable and Linking Format的简称，作为Application Binary Interface(ABI)的一部分，是Unix System Laboratories(USL)推出和制定的，是Unix、Linux以及一些类Unix系统使用的一套可执行文件结构标准，Linux下常见的.o,.so以及可执行文件都是ELF文件格式。
ELF文件格式出现的目的是为不同架构的机器提供一个较为统一的规范，减少重新编码、编译的工作量。
ELF文件在Linux中有三种类型：
 Relocatable File: 可重定位文件，承载代码(说成指令更准确)和数据，可以同其他的**.o**文件一起经由链接器生成Executable File(可执行文件)或者Share Object file(共享对象文件，或者叫动态链接库)。 Executable File：可执行文件，可以被执行，文件中的包含了要被执行的指令和数据等，以及指明了如何创建一个程序的进程镜像。 Shared Object File：共享对象文件，类似于Windows下的Dynamic Link Library(动态链接库)，共享对象文件可以有如下两种Link环境:  同其他的Relocatable File或者Shared Object File组成一个新的Object File文件 通过动态链接的方式，同其他的Shared Object File以及Executable File组成进程镜像。    File Format(文件结构) ELF的Object File参与了程序的Link和执行，不同的阶段，其文件中的结构略有不同，下表给出了组织结构：
   Link View Execution View     ELF Header ELF Header   Program header table(optional) Program header table   Section 1 Segment 1   &amp;hellip; &amp;hellip;   Section n Segment n   &amp;hellip; &amp;hellip;   Section header table Section header table(optional)      ELF Header 包含整个文件的路线图，描述了整个的文件的组成结构 Section 包含了说有Link需要的数据，如指令(instruction)，数据(data)，符号表(Symbol Table)，重定位信息(Relocation Infomation) Program header table 告诉系统如何创建程序的进程镜像。用于创建进程镜像的文件必有Program header table，相反，重定位文件可以没有 Section header table 包含了描述文件中各个section的信息，每个Section在表中都有一个对应的条目，其中包含了Section Name，Size等信息。linking过程中文件必须提此表，其他情形，如已经被链接一个可执行文件可以不需要。   （需要注意的是，ELF文件的结构并不一定是上面表中所列的顺序，事实上除了ELF Header一定在文件头部外，其他部分的顺序都是可变的）</description>
    </item>
    
    <item>
      <title>Linux Hook Notes</title>
      <link>http://blog.exiahan.com/posts/linux_hook_notes/</link>
      <pubDate>Wed, 29 Jul 2015 09:59:25 +0800</pubDate>
      
      <guid>http://blog.exiahan.com/posts/linux_hook_notes/</guid>
      <description>Foreword For have read a article in WebSite code project, and learned lots of from it. So make a memo for later consulting.
Start First we will make some file for the lab.So we need three file, a .h file, two .c file, the code showed below.
//file mylib.h #ifndef _MYLIB_H_ #define _MYLIB_H_  extern void myprint(const char *str); #endif //file mylib.c #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;sys/types.h&amp;gt;#include &amp;lt;unistd.h&amp;gt;#include &amp;#34;mylib.h&amp;#34; void myprint() { static unsigned counter = 0; counter++; printf(&amp;#34;%d, pid (%d)&amp;#34;, counter, getpid()); return; } //mymain.</description>
    </item>
    
    <item>
      <title>SubsTrate with AndroidStudio</title>
      <link>http://blog.exiahan.com/posts/substrate_with_androidstudio/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://blog.exiahan.com/posts/substrate_with_androidstudio/</guid>
      <description>参考文档： 看雪，光哥博客，乌云知识库
0x1 介绍 在家木事，学了下substrate用法，这里记录下～
*Substrate是大名鼎鼎的Cydia团队开发的一套框架工具，支持iOS和Android，相比于Xposed而言，Substrate不仅能提供java层函数的Hook，更能对Native层的C函数进行Hook，而且使用上也比Xposed要方便一些，而且官方提供的文档***也比较全，查阅也比较方便，本文将实现一个简单的C函数Hook例子。
0x2 准备工作  确保设备已经root，注意，测试发现目前substrate暂不支持Android Lollipop及其更新版本 按照官方说明，下载substrate框架apk并安装，重启设备 下载sdk到本地并解压，官方提供了两种方式  直接下载 通过Android SDK Manager管理下载：说明页面    0x3 Substrate with Android Studio 首先还是要吐槽下Android Studio至今对NDK的支持依然不敢恭维，而且一个版本一个config文件夹的本地文件夹命名方式也实在让人实在难受。。 言归正传：
 新建一个工程，名字随意，比如HelloSubstrate 由于是个C函数Hook的例子，所以不需要有activity（其实连java层的源码都不需要 在Project的app文件夹下创建子路径**./lib/armabi/**，把sdk里对应的文件夹下的.so文件丢进去 在src/main下创建子路径**./jni**，创建一个**xxx.cy.cpp**文件用来存放c层源码，同时把substrate.h文件丢进去（注意这里文件名结尾必须是cy.cpp，substrate文档里要求这么做，用于识别&amp;mdash;文档 在manifest文件里加上权限声明，否则无法正常工作  &amp;lt;uses-permission android:name=&amp;quot;cydia.permission.SUBSTRATE&amp;quot;/&amp;gt;    额外的准备工作 又要吐槽Android Studio了，ndk的整合上十分混乱，到现在为止已经有三种使用ndk的方法了，使用以前的的方法会提示gradle警告，但能通过，不过为了紧跟潮流，这里试用最新的方法，步骤如下：
 确保你的gradle是最新的 修改./Project/build.gradle的classpath为  classpath &#39;com.android.tools.build:gradle-experimental:0.2.0&#39;   修改./Project/app/build.gradle为如下样式：注意其中的不同  apply plugin的模块变了 所有变量都要用 &amp;ldquo;=&amp;rdquo; 来赋值，以前可以是*&amp;ldquo;变量名 空格 值&amp;rdquo;*的形式    apply plugin: &amp;#39;com.android.model.application&amp;#39; model { android { compileSdkVersion = 23 buildToolsVersion = &amp;#34;23.</description>
    </item>
    
  </channel>
</rss>