<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Reverse on ExiaHan&#39;s Blog</title>
    <link>https://blog.exiahan.com/tags/reverse/</link>
    <description>Recent content in Reverse on ExiaHan&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 07 Oct 2015 23:20:29 +0800</lastBuildDate>
    
	<atom:link href="https://blog.exiahan.com/tags/reverse/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Dump Dex From IJiaMi</title>
      <link>https://blog.exiahan.com/posts/dump_dex_from_ijiami/</link>
      <pubDate>Wed, 07 Oct 2015 23:20:29 +0800</pubDate>
      
      <guid>https://blog.exiahan.com/posts/dump_dex_from_ijiami/</guid>
      <description>内容仅供学习讨论 参考文档： 爱加密动态脱壳，爱加密动态脱壳法，浅谈android逆向分析那些拦路虎，光哥博客
0x1 说在开头 现在有很多软件都是有加壳的，作为安全狗肯定要研究研究，从网上找了点资料，然后找了个用IJiaMi加固的顺着做了一下。
0x2 实验环境  Android 真机，Version 4.1.2， with ROOT &amp;amp; Xposed 某被IJiaMi加固的App IDA调试器 adb  0x3 过程 下断点：
 libc.so fgets fopen libdvm.so _Z21dvmDexFileOpenPartialPKviPP6DvmDex  这里关于为何在fgets和fopen上下断点的原因几乎都有说明，是因为加固措施里有反调试，方法是使用子进程检测父进程是否被ptrace（即被调试），如果有则强制关闭说有进程，而检测方法就是读取
|---/proc/[pid]/status 对于这个我也写了个，大概实现可以看这里：getTracerPid
文件里的TracerPid行，如果为0说明没有被调试，否则就是调试器的PID 所以要在fgets和fopen上下断，找到其打开后获取值的语句，改为0,patch掉反调试
真正调试时发现其实不需要每次都patch掉，只要找到用于反调试的子进程，然后直接休眠掉即可，否则如果碰到变态的每隔几秒就检测一次的加固方式，那就只能一直人工patch了┗&amp;lt;(=｀o′=)&amp;gt;┓哼 ┏&amp;lt;(=｀○′=)&amp;gt;┛哼┏&amp;lt;(=｀o′=)&amp;gt;┓哈┗&amp;lt;(=｀O′=)&amp;gt;┛兮！！
再下来是**_Z21dvmDexFileOpenPartialPKviPP6DvmDex**，位于libdvm.so，libdvm是library-dalvik-virtual-machine，即dalvik虚拟机的核心所在shared object，其中的*_Z21dvmDexFileOpenPartialPKviPP6DvmDex*即为运行一个dex前需要调用的**参与打开dex文件**的一个函数，为什么要在这里下断呢？
去源码dalvik文件夹下执行
grep -rn dvmDexFileOpen 可以找到dvmDexFileOpenPartial函数，其定义位于./dalvik/vm/DvmDex.h:84，如下：
72 /* 73 * Given a file descriptor for an open &amp;#34;optimized&amp;#34; DEX file, map it into 74 * memory and parse the contents. 75 * 76 * On success, returns 0 and sets &amp;#34;*ppDvmDex&amp;#34; to a newly-allocated DvmDex.</description>
    </item>
    
    <item>
      <title>Dice Write Up</title>
      <link>https://blog.exiahan.com/posts/dice_write_up/</link>
      <pubDate>Fri, 18 Sep 2015 20:01:27 +0800</pubDate>
      
      <guid>https://blog.exiahan.com/posts/dice_write_up/</guid>
      <description>0x1 题目链接：Simple-Reverse-Dice
0x2 拿到程序后运行观察其行为，发现是一个Windows CLI程序，运行后提示是按其要求摇骰子，摇出其指定的点数才能进行到下一步，全部正确则吐出Flag，错误则结束。
运行时程序会有一些提示字符串，记下部分，用IDA打开静态分析。
0x3 使用IDA和Ollydbg进行分析
 在String Tab中找到对应的String，找到其关联的代码，转成C伪代码分析，可以看到程序是一个WinMain程序，查看其变量，发现有两个time类型，推测可能每次摇骰子是随机生成数值。 继续向下，可以看到程序有判断是否有附加调试器：  isDebugerPresent()函数，标记，使用Ollydbg时要记得修改其值，绕过调试器检测   继续向下走的话，可以看到每次判断都是调用随机数生成函数后存入值到内存地址0x0022FE9C处，然后从此内存取值，依次判断是否是3-1-3-3-7，需要注意的是最后一个判断7的时候没有再生成随机数，所以要在判断前直接修改内存为7 再继续，3-1-3-3-7完成后，在显示flag之前，还有一次比较，如果相等会跳到something wrong，所以也要做一次patch 仅按照上述内容patch后发现打出的flag是乱码，猜测可能有其他坑，重新浏览代码发现每次判断roll点正确（即3-1-3-3-7）后，还会判断时间差，如果大于2，就会把用来计算flag的值做一次乘2,所以每次比较完后要在比较时间差处也做patch，防止被乘2 最后发现上面最好patch后，加了横线的描述应该不会发生  #0x4 上述步骤完成，拿到flag，如图：
#0x5
昨晚后光哥给的思路是直接运行前静态改好，然后直接让他跑一下就把flag吐出来了。。。o&amp;laquo;(≧口≦)&amp;raquo;o，炸裂了。。我好蠢。。汪，就这样
顺便把我的暴力方法打的断点图备忘一下：</description>
    </item>
    
  </channel>
</rss>