<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>CTF on ExiaHan&#39;s Blog</title>
    <link>http://blog.exiahan.com/categories/ctf/</link>
    <description>Recent content in CTF on ExiaHan&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 30 Dec 2015 22:12:08 +0800</lastBuildDate>
    
	<atom:link href="http://blog.exiahan.com/categories/ctf/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>IDF.CN Practice 01</title>
      <link>http://blog.exiahan.com/posts/idf_cn_practice_01/</link>
      <pubDate>Wed, 30 Dec 2015 22:12:08 +0800</pubDate>
      
      <guid>http://blog.exiahan.com/posts/idf_cn_practice_01/</guid>
      <description>0x1 Preparation 既然决定要做，那就加油，写在开头，打好基础，加油吧。 Exia，斩获未来。。
0x2 Start 一、牛刀小试 被改错的密码 从前有一个熊孩子入侵了一个网站的数据库，找到了管理员密码，手一抖在数据库中修改了一下，现在的密码变成了 cca9cc444e64c8116a30la00559c042b4，那个熊孩子其实就是我！肿么办求解！在线等，挺急的。。
看起来挺像md5,直接拿去在线破，结果提示有问题，再一看，长度有问题，md5是32位哈希，这玩意33位，用python生成去掉其中某个字符的序列，然后再一个个在线破，发现是cca9cc444e64c8116a30a00559c042b4，解出来是idf，所以flag是wctf{idf}
 啥 题目就是一张图片，bless打开看hex，在底部找到flag：wctf{mianwubiaoqing__}
 ASCII码而已 明显一看是unicode，找个在线转换，flag为wctf{moremore_weibo_fans}
 摩斯密码 一段morsecode &amp;ndash; &amp;mdash; .-. &amp;hellip; . -.-. &amp;mdash; -.. . 在线解一下，flag为wctf{morsecode}
 聪明的小羊 一只小羊跳过了栅栏，两只小样跳过了栅栏，一坨小羊跳过了栅栏&amp;hellip; tn c0afsiwal kes,hwit1r g,npt ttessfu}ua u hmqik e {m, n huiouosarwCniibecesnren.
看题目就想到古典加密，既然是栅栏，那就栅栏密码吧，正好带学一下栅栏密码，就写了个python的加解码脚本，跑一下看到flag:wctf{C01umnar}
二、包罗万象 MISC 图片里的英语 给了一张小李，binwalk一下。看到有个rar，dd提取出来，解压，得到一长flag，恩，没错，就是那张赵本山的图片，may the force be with you，然后首字母大写，wctf{Mtfbwy}
 抓到一只苍蝇 给了一个pcapng网络dump包，根据他说的内容，和包名带有fly，搜索包内容，找下字符串fly，成功找到，发现是上传了一个附件fly.rar,分成了5个包上传，第一个post指出fly.rar大小为525701，接着5个包都是传向ftn开头服务器，所以猜测是附件内容，前个都是131436大小，最后一个1777，（131436×4 + 1777 - 525701） / 5 = 364，所以每个包开头364部分为分包后的包头，dd导出内容，skip掉头364字节，然后cat成fly.rar，比较下post里给的md5,一样。
解压工具打开，提示文件损坏，看上去因该不是正常的加密，而且也根本没有其他密码的信息，推测可能改了文件头，bless修改加密位（第24个字节改为0x80）：
解压得到一个flag.txt，打开发现不行，binwalk一看是个pe。。。不过里面有png，而且很多60x60的，但有一个280x280的，dd解出来，打开是一张二维码，扫一下，flag为:flag{m1Sc_oxO2_Fly}，不过说没改格式，额，所以应该是wctf{m1Sc_oxO2_Fly}
三、初探乾坤 PPC 简单编程-字符统计 给了一串字符串，让统计个数，妥妥的python，count函数直接搞定。直接提交，发现有坑，仔细看了下题目是要求2秒内搞定，那就只能自动接受内容然后发送post请求了</description>
    </item>
    
    <item>
      <title>MSC2015 WriteUp</title>
      <link>http://blog.exiahan.com/posts/msc2015_writeup/</link>
      <pubDate>Thu, 22 Oct 2015 17:45:08 +0800</pubDate>
      
      <guid>http://blog.exiahan.com/posts/msc2015_writeup/</guid>
      <description>第一题 和去年类似，程序运行后要求输入，输入正确的值才能得到答案，打开DDMS监控，尝试输入字符串查看log并观察其行为，Log里有提示invalid int，说明要求输入的是个int范围内的数。
把程序丢到jeb里查看，发现关键函数check无法被解析
使用apktool d -d反编译查看smali代码，看到反编译出了5万行代码，其中有大量通过动态反射调用的函数，但是调用的都是java库函数，函数名硬编码成Reverse字符串，运行时逆转成真正的函数名。但是猜测既然是输入的数字，应该会有比较，使用apktool b -d重打包，真机运行，使用netbeans动态调试，并且在check方法的所有cmp处下断点，最终在45540行的比较处发现，如果比较结果是不等，那么返回false，如果是true，则通过校验，程序显示蓝色字。
多次运行，输入不同的数字，发现v10会变化，但是v4是定值，520676，说明v10应该和输入有关，向上找会修改v10的地方，找到第36111行，在此处下断，运行。
输入123456789，发现第一次断在此处v20值是123456790,继续运行会再次断在此处，如此循环，循环结束后继续运行会跳到关键的比较行，在比较行上有把v6和v4相加存入v4的操作。查找循环的比较条件，可以看到15983行有个v0和v5的比较，其中v5是定值1001,直接修改v0为1001,则最终v4的值不再是520676,同时v10的值也不再是之前输入123456789的值，所以36111行处应该和计算过程相关，是核心过程，继续向上找36111行v20的相关行，找到10832行。
重新运行程序，输入123456789，程序断在此处是，v10是输入值，v8的值从v0处取得，v0的值变化规律为从1开始递加4,一直到1001,然后15983行的比较生效，跳转，最终运行到关键比较点。 使用python脚本计算1到1001的递增为4的累加值，为124750，让程序一直运行到比较点，观察v10的值为123581539，减去124750,刚好为输入。
用v4的值减去124750,得到395926，即为key
第二题 首先丢到jeb里分析，Ch函数里有个Morse码，解码后是WOJIUSHIDAAN，输入后不对，猜测是个坑。。 同时Ch里有做签名校验，重打包时需要patch掉。 apktool d -d 反编译，同时修改Ch的smali代码
116 a=0;// #v2=(Reference,Ljava/lang/String;); 117 a=0;// const-string v1, &amp;quot;WJmkxxkkGnYbExi3dqzeaA&amp;quot; ...... 120 a=0;// 121 a=0;// move-result v1 122 a=0;// 123 a=0;// #v1=(Boolean); 124 a=0;// if-eqz v1, :cond_0 //需要修改的行 同时发现有native方法ch用来check，使用ida动态调试，直接闪退，有反调试。静态分析，导出表还有mprotect，同时猜测可能有动态修改执行代码。 最终在init_array里找到两个反调试的入口点,1424和3160
1424和3160里分别有调用到sub_1284和sub_3400，前者很明显去调用fopen读取 proc/pid/status的tracerpid，后者在运行时会被多次调用，包括在动态释放的代码里也会调用，如果返回一个小于0的值，那么会尝试像不可写内存里写值，导致程序崩溃。
使用bless打patch，把1284里的kill调用改为返回0,3400里的返回值改成0,使用的opcode是00 00 A0 E3 mov R0, #0，修改后如图：
重新附加调试器，可以正常调试，在Java_k2015_a2_Ch_ch处下断点，让程序继续运行，输入abcdefg，成功断在native函数ch处，运行到sub_1DE0[0x3CBAFDE0]时单步进入，此时可以看到传入参数为输入
sub_1DE0中输入给了v1,然后mcpy到v43，最终在两个mprotect（其中有动态修改程序代码），后调用了函数loc_24C8[0x3CBB04C8]，步入前先使用idc脚本dump出来libwbox.so,此时的so里含有24C8的代码，可以用来静态分析，然后步入函数，查看其代码，对输入的字符串做了如下变换：
变换后依然有动态修改代码的过程，然后调用loc_14A4[0x3CBAF4A4]，同样调用前dump出来so库，用于静态分析代码算法，在调用前会对输入进行变换，方法是输入的第i个元素的ASCII码加上i再存回数组，此时输入已经变为如下所示：
在loc_14A4中会对输入再次变换，最终生成下面提到的16字节数组，计算方式如图：
如图，用于计算的数组是[1F BC DA FF E6 4C BC 44 F5 B8 13 C8 EC A8 CD BD],计算方式是第i个元素的ASCII码加上上面对应的第i个数，结果保存为一个16字节数组。</description>
    </item>
    
    <item>
      <title>XDCTF2015 WRITEUP(我才不会说我就做出来一题)</title>
      <link>http://blog.exiahan.com/posts/xdctf_writeup/</link>
      <pubDate>Fri, 02 Oct 2015 23:12:46 +0800</pubDate>
      
      <guid>http://blog.exiahan.com/posts/xdctf_writeup/</guid>
      <description>0x1 给大黑阔们跪了 本来准备出去玩的，结果到家后发现要过两天才有人回来，就趁机做了把XDCTF的线上，结果被虐的北都找不到了，看着6星和Sigma一路突突突，只能膜了。。有思路的一共三题，结果最后只做出来1题。。。另外两题做到一大半怎么也进行不下去了。 总体来说虽然没做出来多少，但是感觉XDCTF水平是很高的了，题目也都很虐人（Pia!&amp;lt;(=ｏ ‵-′)ノ☆ 这里写个备忘，毕竟是一次经历。
0x2 没写出来但有思路的的 Reverse 01 一个linux 的elf x64程序，还是挺有意思的，可惜没做出来，逆向功力不够，大概思路：
 入口函数是函数0x4008e1，里面会有ptrace反调试，然后获取输入  这里的输入从分析看应该是要解密后面说到的加密方法的   后面的坑就来了，如果顺着0x4008e1走，最后会打印出来&amp;quot;Congratulations? Key is XDCTF{Input}&amp;quot;，一看就不对 继续看，发现有个函数在0x400787,最后也会打印出来一个flag，而且会吧上面的string的“？”换成“！”，所以这个函数才是真正会吐出flag的过程 解体思路应该是修改执行流到这里，但是问题有三个：  逆向出加密算法 给出能通过的输入 在什么时刻强制从0x4008e1跳到0x400787   因为没搞定上面三个问题，所以没写出来  最后说下里面加密会用到字符串ZzAwZF9DcjRrM3JfZzBfb24=，不过加密算法，我就真不想看了。
Misc 01 这题后来给了tips，也就是org原图。
 先用stegsolv打开zzzzzzyu.png，跳几个plane后可以看到顶部有个条，原图org.png是没的 用stegsolve两张combine一下，然后sub后发现顶部会出现两像素宽的条状区，里面零星分布一些黑色像素点 导出成bmp，去色成黑白 用python 的PIL库把顶部两行的按照像素输出，白色是0,黑色是1,可以得到如下字符串：  11111111111111111111111111111110111111111111111111101011111111111111110111111111111111111011111111111111111111111110111111111111111101011111111111111111111111111111110111111110101110111111111111111111111111111011101110111111111111111111111111110111111111111111111111011111110111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111101111111111111111110101111111011111010111111011111111111111111111111111111111111111111110111111111111111111010111111101111101011111101111111111111111111111111111111101110111111111111111 但是接下来用jpk处理的时候，4bit格式format，然后处理完实在找不到什么特征了。。作罢。。。（o&amp;laquo;(≧口≦)&amp;raquo;o
0x3 解出来的 嘛，怎么着还是做出来一题的，至少不是鸭蛋，咩哈哈哈哈&amp;lt;(=￣_￣)σ…&amp;lt;( ＿ ＿)ノ｜
给了一个数据文件，file一下识别不了格式，strings也没啥有用信息，bless看的时候发现开头几个字符是VIMG&amp;hellip;.fat12&amp;hellip;.VMWare Visual什么的，搜了下，唯独fat12有点信息，但是挂载的话还是会失败。
换用binwalk，可以看到里面有很多东西，但是有两个zip文件，而且最后那个里面有flag.txt，于是把两个都dd出来 不过要说的是dd中间那个的时候，如何能精确的dd出来还是听麻烦的，试了好久，dd出来了一个没有多余附加尾部的zip，如果有更好的方法还希望有人留言说下哈
dd出来后有flag的那个，姑且命名为flag.zip有密码，试着去掉密码位后一样不行，说明不是伪加密，再看没加密的那个，姑且命名为x.zip，发现两个都有个readme.txt
用unzip -v查看了下两个的内容，结果两个readme.txt相同诶，于是想到明文破解，把x.zip里除readme.txt外的文件全部删掉，然后用pkcrack大法，大概用法是
pkcrack -c &amp;ldquo;readme.txt&amp;rdquo; -p raedme.txt -C flag.zip -P x.zip -d ok.zip
 -c是指出加密zip里readme.</description>
    </item>
    
    <item>
      <title>NSCTF2015 WriteUp</title>
      <link>http://blog.exiahan.com/posts/nsctf2015_writeup/</link>
      <pubDate>Fri, 25 Sep 2015 20:56:06 +0800</pubDate>
      
      <guid>http://blog.exiahan.com/posts/nsctf2015_writeup/</guid>
      <description>参加了NSCTF线上比赛，感觉自己水平还是有待提高啊，写一下做出来的题目的备忘
Reverse 0x1 简单的逆向 题目地址：Reverse01
 运行程序，出现CLI程序窗口，提示输入密码，随意输入，提示错误。 使用PEID查看，发现加了ASPACK2.12的壳，使用od加载，看到有pushad操作，使用esp方法脱壳 不需要完整脱壳，在壳程序运行完，dump程序[此步不是必须，但是可以dump出来后查看源码] 回到od，查找字符串，找到提示的那句**&amp;ldquo;please input ns-ctf password&amp;rdquo;**，跳转到引用文字，发现有strcmp比较，比较字符串固定，为**&amp;ldquo;nsF0cuS!x01&amp;rdquo;** 输入上面的字符串**&amp;ldquo;nsF0cuS!x01&amp;rdquo;** 单步跟踪，发现有个jle跳转，如果条件满足会跳过一个函数调用，直接printf出来一个有乱码的flag，推测可能之前还有处理 修改jle跳转为改为**&amp;ldquo;jmp short Reverse0.00401150&amp;rdquo;**，即调用其本来会通过jle跳过的函数，如图：   继续F9运行，程序吐出flag，如图：  0x2 较简单的逆向 题目地址：Reverse02
本题和第一题类似，只不过改成了窗口程序
 运行，发现窗口程序 使用OD或者IDA打开 尝试搜索&amp;quot;Flag&amp;rdquo;，发现有好几个匹配，记下，同时猜测可能和第一题一样有对flag处理 查看导入表，发现是个dialogbox，查找调用，找到0x00401240处的DialogBoxParamA调用，从其参数里找到对应回调处理函数入口为0x00401180 转到0x00401180处，发现有个GetDlgItemTextA的调用，在其下有个call 0x00401070，猜测会在其中处理Flag，修改程序执行流，让其可以执行，跟踪进入此函数，如图：   进入0x00401070后，可以看到上面有个0x00401000的函数，可以看到内部有调用MessageBoxA显示Flag，同时在0x00401070内发现有此函数调用，修改执行流让其可以执行，跟踪进入0x00401000，在MessageBoxA调用前下断，看到真正的flag，如图：  0x3 逆向 题目地址：Reverse03
分析：使用python生成的程序，运行时在本地Temp文件夹里释放文件，通过CreateProcessA运行一个新进程来执行，没搞定。。。。。。。。囧。。
MISC 0x1 Twitter 这题，额。。。啧啧。。一个md5,100块钱，不过有人抖了答案出来
0x2 Wireshark 题目地址：sniffer.pcapng
从题目可以看出来是个抓包题，wireshark打开文件[也可以用Dshell，或者binwalk]
 题目说是下载，猜测在http里，表达式过滤http 看到有个key.rar，服务器为192.168.52.1 dump出key.rar，解压，需要密码 继续查找发现获取rar之前还有个从服务器获取的页面，dump内容保存成html文件，内容有提示密码为nsfocus+5个数字 生成字典，爆破，解压密码为nsfocus56317,打开后获得flag  WEB 0x1 Be Careful 使用chrome dev tools跟踪页面，发现有个301重定向，猜测可能有个默认的动态页面，尝试index.php，发现确实存在，使用wireshark抓包，看到flag在注释里。
###0x2 Decode
题目里给了个php的函数，接受传入的字符串
function encode($str){ $_o = strrev($str); for($_0=0;$_0&amp;lt;strlen($_o);$_0++){ $_c = substr($_o,$_0,1); $__ = ord($_c)+1; $_c = chr($__); $_= $_.</description>
    </item>
    
    <item>
      <title>Dice Write Up</title>
      <link>http://blog.exiahan.com/posts/dice_write_up/</link>
      <pubDate>Fri, 18 Sep 2015 20:01:27 +0800</pubDate>
      
      <guid>http://blog.exiahan.com/posts/dice_write_up/</guid>
      <description>0x1 题目链接：Simple-Reverse-Dice
0x2 拿到程序后运行观察其行为，发现是一个Windows CLI程序，运行后提示是按其要求摇骰子，摇出其指定的点数才能进行到下一步，全部正确则吐出Flag，错误则结束。
运行时程序会有一些提示字符串，记下部分，用IDA打开静态分析。
0x3 使用IDA和Ollydbg进行分析
 在String Tab中找到对应的String，找到其关联的代码，转成C伪代码分析，可以看到程序是一个WinMain程序，查看其变量，发现有两个time类型，推测可能每次摇骰子是随机生成数值。 继续向下，可以看到程序有判断是否有附加调试器：  isDebugerPresent()函数，标记，使用Ollydbg时要记得修改其值，绕过调试器检测   继续向下走的话，可以看到每次判断都是调用随机数生成函数后存入值到内存地址0x0022FE9C处，然后从此内存取值，依次判断是否是3-1-3-3-7，需要注意的是最后一个判断7的时候没有再生成随机数，所以要在判断前直接修改内存为7 再继续，3-1-3-3-7完成后，在显示flag之前，还有一次比较，如果相等会跳到something wrong，所以也要做一次patch 仅按照上述内容patch后发现打出的flag是乱码，猜测可能有其他坑，重新浏览代码发现每次判断roll点正确（即3-1-3-3-7）后，还会判断时间差，如果大于2，就会把用来计算flag的值做一次乘2,所以每次比较完后要在比较时间差处也做patch，防止被乘2 最后发现上面最好patch后，加了横线的描述应该不会发生  #0x4 上述步骤完成，拿到flag，如图：
#0x5
昨晚后光哥给的思路是直接运行前静态改好，然后直接让他跑一下就把flag吐出来了。。。o&amp;laquo;(≧口≦)&amp;raquo;o，炸裂了。。我好蠢。。汪，就这样
顺便把我的暴力方法打的断点图备忘一下：</description>
    </item>
    
  </channel>
</rss>